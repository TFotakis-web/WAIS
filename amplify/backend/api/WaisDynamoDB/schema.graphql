type Trade
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: owner, ownerField: "ownerUsername", operations: [read, update] }
      { allow: members, ownerField: "members", operations: [read] }
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byTradeName", fields: ["tradeName", "ownerUsername"], queryField: "listTradeByName")
  @key(name: "byOwnerUsername", fields: ["ownerUsername", "tradeName"], queryField: "listTradeByOwnerUsername") {
  # Trade details
  tradeName: String!
  ownerUsername: String!
  tin: String!
  logo: String!
  info: String!
  postcode: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!

  # Owner UserProfile
  ownerProfile: UserProfile
    @connection(fields: ["ownerUsername"])
    @auth(
      rules: [
        { allow: owner, ownerField: "ownerUsername", operations: [read] }
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  # Users that can access this object (excluding Admins/Lambdas)
  members: [String]!
    @auth(
      rules: [
        { allow: owner, ownerField: "ownerUsername", operations: [read] }
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  # Standard employees of this trade
  employees: [TradeUserConnection]
    @connection(keyName: "byTradeName", fields: ["tradeName"])
    @auth(
      rules: [
        { allow: owner, ownerField: "ownerUsername", operations: [read] }
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  # Contractors working associated with this trade
  contractors: [TradeUserConnection]
    @connection(keyName: "byTradeName", fields: ["tradeName"])
    @auth(
      rules: [
        { allow: owner, ownerField: "ownerUsername", operations: [read] }
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  # Accesses requested by this trade
  fromCompanyAccess: [CompanyAccessConnection]
    @connection(keyName: "byFromTradeName", fields: ["tradeName"])
    @auth(
      rules: [
        { allow: owner, ownerField: "ownerUsername", operations: [read] }
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  # Accesses made by others to this trade
  toCompanyAccess: [CompanyAccessConnection]
    @connection(keyName: "byToTradeName", fields: ["tradeName"])
    @auth(
      rules: [
        { allow: owner, ownerField: "ownerUsername", operations: [read] }
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  # Contracts associatec with this Trade
  contractConnections: [TradeContractConnection]
    @connection(keyName: "byTradeName", fields: ["tradeName"])
    @auth(
      rules: [
        { allow: owner, ownerField: "ownerUsername", operations: [read] }
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  customers: [Customers]
    @connection(keyName: "byTradeName", fields: ["tradeName"])
    @auth(
      rules: [
        { allow: owner, ownerField: "ownerUsername", operations: [read] }
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )
}

type UserProfile
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: owner, ownerField: "username", operations: [read, update] }
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byUsername", fields: ["username", "telephone"], queryField: "listUserProfileByName") {
  # Important field(s)
  username: String!

  #Unique fields, not present anywhere eles
  telephone: String
  tin: Int!
  doy: String!
  familyStatus: String!
  chamberRecordNumber: String!
  insuranceLicenseExpirationDate: AWSTimestamp!
  partnersNumberLimit: Int!
  professionStartDate: String!
  file: [S3Object]

  # Connected with ONE trade if its a STANDARD user or multiple trades if its a CONTRACTOR
  tradeCon: [TradeUserConnection]
    @connection(keyName: "byUserName", fields: ["username"])
    @auth(
      rules: [
        { allow: owner, ownerField: "username", operations: [read] }
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )
}

type Vehicle
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: owner, ownerField: "members", operations: [read] }
      { allow: groups, groups: ["admin"] }
      { allow: private, provider: iam }
    ]
  )
  @key(name: "byTradeName", fields: ["tradeName", "vehicleId"])
  @key(name: "byNumberPlates", fields: ["numberPlate", "vehicleId"])
  @key(name: "byNumberPlates", fields: ["numberPlate", "vehicleId"]) {
  vehicleId: ID!
  tradeName: String!
  numberPlate: String!
  color: String!
  manufacturer: String!
  model: String!
  vehicle_owner: String!
  trim: String!
  fuelType: String
  usage: String!
  displacement: Int!
  eurotax: Int!
  firstRegistrationDate: String!
  passengers: Int!
  purchaseDate: String!
  taxableHorsepower: Int!
  vin: String!
  value: Float!
  file: [S3Object]
  members: [String]
}

type Contract
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: owner, ownerField: "members", operations: [read] }
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byTradeName", fields: ["tradeName", "createdAt"])
  @key(name: "byCustomerId", fields: ["customerId", "tradeId"]) {
  createdAt: String!
  voucherId: ID!
  vehicleId: ID!
  customerId: ID!
  tradeId: ID!
  second_tradeId: ID #Optional
  contractorId: ID #Optional
  co_name: String # CoSign participant name (OPTIONAL)
  co_TRN: String # CoSign participant "AFM" (OPTIONAL)
  contractState: String! # Send to S3 on completion
  insuranceClass: String!
  insuranceCoverage: [String]
  insuranceUsage: String
  duration: String!
  creationDate: String!
  startDate: String!
  endDate: String!
  data: String!
  discount: Float! # e.g. 0.1
  jointWorth: Float!
  netWorth: Float!
  driversLicense: DriversLicense
  members: [String]
  vehicle: Vehicle @connection(fields: ["vehicleId"])
}

type Customer
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: owner, ownerField: "members", operations: [read] }
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byEmail", fields: ["email", "firstName", "lastName"])
  @key(name: "byTradeName", fields: ["tradeName", "firstName", "lastName"]) {
  tradeName: ID!
  tin: Int
  firstName: String
  lastName: String
  fathersName: String
  birthDate: String
  gender: String
  email: String!
  mobile: String
  postcode: String
  doy: String
  address: String
  familyStatus: String
  creationDate: AWSTimestamp!
  files: [S3Object]
  driversLicense: DriversLicense
  members: [String]
}

type TradeUserConnection
  @model(subscriptions: null)
  @key(name: "byTradeName", fields: ["tradeName", "username"])
  @key(name: "byUsername", fields: ["username", "tradeName"])
  @auth(
    rules: [
      { allow: owner, ownerField: "members", operations: [read] }
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  ) {
  tradeName: String!
  username: String!
  trade: Trade! @connection(fields: ["tradeName"])
  user: UserProfile! @connection(fields: ["username"])
  permissions: [UserPermissions]
  employeeType: EmployeeType! # e.g Contractor
  preferences: String

  # Users that can access this connection. e.g Admin/User
  members: [String!]!
}

type CompanyAccessConnectionRequest
  @model(queries: null, mutations: null, subscriptions: null)
  @key(name: "byFromId", fields: ["fromId", "toId"])
  @key(name: "byToId", fields: ["toId", "fromId"])
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID!
  fromId: ID!
  toId: ID!
  from: Trade! @connection(fields: ["fromId"]) #This trade initiates the collaboration
  to: Trade! @connection(fields: ["toId"]) #This trade needs to accept the collaboration
  expirationDate: AWSTimestamp! # Can be used to configure a TTL workflow
  message: String!
}

type TradeContractConnection
  @model(queries: null, mutations: null, subscriptions: null)
  @key(name: "byTradeId", fields: ["tradeId", "contractId"])
  @key(name: "byContractId", fields: ["contractId", "tradeId"])
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID!
  tradeId: ID!
  contractId: ID!
  trade: Trade! @connection(fields: ["tradeId"])
  contract: Contract! @connection(fields: ["contractId"])
  ownsContract: Boolean! #If true then the Trade can edit the Contract
}

type CompanyAccessConnection
  @model(subscriptions: null)
  @key(name: "byFromId", fields: ["fromId", "toId"])
  @key(name: "byToId", fields: ["toId", "fromId"])
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID!
  fromId: ID!
  toId: ID!
  from: Trade! @connection(fields: ["fromId"]) #This trade initiates the collaboration
  to: Trade! @connection(fields: ["toId"]) #This trade needs to accept the collaboration
  expirationDate: AWSTimestamp! # Can be used to configure a TTL workflow
  message: String!
}

#For callendar use
type UserCalendarEvent
  @model(subscriptions: null)
  @auth(rules: [{ allow: owner, ownerField: "username" }, { allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  username: String!
  createdAt: String!
  payload: String
}

type UserWallet
  @model(subscriptions: null)
  @key(name: "byUsername", fields: ["username"])
  @auth(
    rules: [
      { allow: owner, operations: [read], ownerField: "username" }
      { allow: groups, groups: ["admin"] }
      { allow: private, provider: iam }
    ]
  ) {
  username: String!
  balance: Float!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type TransactionHistory
  @model(subscriptions: null)
  @key(name: "bySenderId", fields: ["senderId", "timestamp", "receiverId"])
  @key(name: "byReceiverId", fields: ["receiverId", "timestamp", "senderId"])
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  timestamp: AWSTimestamp!
  senderUsername: ID! # UserProfile ID
  receiverUsername: ID!
  transactionAmount: Float!
  sender: UserProfile! @connection(fields: ["senderId"])
  receiver: UserProfile! @connection(fields: ["receiverId"])
  senderWallet: UserWallet! @connection(fields: ["senderId"])
  receiverWallet: UserWallet! @connection(fields: ["receiverId"])
}

type AdminRequests
  @model(subscriptions: null)
  @key(name: "byTradeId", fields: ["tradeId"])
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  expiresAt: AWSTimestamp!
  message: String!
  profile: UserProfile!

  #Request fields
  tradeId: ID!
  tradeName: String!
  logo: String
  info: String!
  postcode: String!
}

type TestType @model(subscriptions: null) {
  id: ID!
}

# ####################################################################################################################################################################################

# Everyone can call this queries
# Authentication is performed inside the lambda resolver
type Query {
  #Utils
  me: User @function(name: "resolver-${env}") @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  user(username: String!): User
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  echo(msg: String!): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])
}

type Mutation {
  #Admin API
  requestAdminAproval(tradeId: String!, message: String!): String  #Returns the request ID
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  adminAproveRequest(id: String!): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  #Manage company connections
  createCompanyConnectionRequest(email: String): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  replyToCompanyConnectionRequest(id: ID, status: ConnectionStatus): ConnectionStatus
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  # Trade user management
  addEmployeeToTrade(username: String!): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) #TODO add types
  #updateEmployeePermissions(username: String!, permissions: UserPermissions): String @function(name: "resolver-${env}")

  # Update user Files
  putFile(name: String, key: String): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  getFile(name: String): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  # Update user balance
  sendMoneyToUserWithUsername(receiverUsername: String, amount: Float!): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])
}

###################### ENUMS/TYPES ######################

#Add all department-specific
type UserPermissions {
  department: String #User defined
  read: Boolean
  write: Boolean
}
type S3Object {
  bucket: String!
  region: String!
  key: String!
}

enum EmployeeType {
  STANDARD
  CONTRACTOR
}

type DriversLicense {
  LicenseID: Int
  DriversLicenseType: String # Erasitexniko/Epaggelmatiko
  Category: [DriversLicenseCategory]
}

type DriversLicenseCategory {
  category: String
  issueDate: String
  expiresAt: String
}

type InsurancePackage {
  name: String!
  insuranceClass: String!
  coverage: [String]
  usages: String
}

# These types derived from https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/CognitoIdentityServiceProvider.html#adminGetUser-property
type User {
  Username: String!
  UserAttributes: [Value]
  UserCreateDate: String
  UserLastModifiedDate: String
  Enabled: Boolean
  UserStatus: UserStatus
  MFAOptions: [MFAOption]
  PreferredMfaSetting: String
  UserMFASettingList: String
}
type Value {
  Name: String!
  Value: String
}
type MFAOption {
  DeliveryMedium: String
  AttributeName: String
}
enum UserStatus {
  UNCONFIRMED
  CONFIRMED
  ARCHIVED
  COMPROMISED
  UNKNOWN
  RESET_REQUIRED
  FORCE_CHANGE_PASSWORD
}

enum ConnectionStatus {
  ACCEPTED
  REJECTED
}

# Used to model a Cognito user, not a 'real' DynamoDB type
# type UserCognito {
#   id: ID! # Custom attribute
#   name: String! # Full Name (includes middle name)
#   given_name: String! # First name
#   family_name: String! # Surname
#   middle_name: String! # Father's name!
#   preferred_username: String!
#   picture: String!
#   email: String!
#   email_verified: Boolean!
#   gender: String!
#   birthdate: String!
#   locale: String!
#   phone_number: String!
#   phone_number_verified: Boolean!
#   address: AWSJSON! # Specific json, check https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims
#   updated_at: AWSDateTime!
# }
