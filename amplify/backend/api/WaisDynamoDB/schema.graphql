# Each office has one owner and each owner hast one office, always!
type Office
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: owner, ownerField: "ownerUsername", operations: [read] }
      { allow: owner, ownerField: "members", operations: [read] }
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byTradeName", fields: ["tradeName", "ownerUsername"], queryField: "listTradeByName")
  @key(name: "byOfficeEmail", fields: ["office_email"], queryField: "listTradeByOfficeEmail")
  @key(name: "byOwnerUsername", fields: ["ownerUsername", "tradeName"], queryField: "listTradeByOwnerUsername") {
  # UID of this office
  id: ID

  # Protected info
  tradeName: String!
  ownerUsername: String!
  address: String
  office_email: String!
  zip_code: String
  mobile: String
  phone: String!
  partnersNumberLimit: Int
  employeesNumberLimit: Int
  verified: Boolean

  # Private data
  # Consider making this a connection if there is a need to search for an office based on such data.
  privateData: OfficePrivateDetails!
    @auth(
      rules: [
        { allow: owner, ownerField: "ownerUsername", operations: [read] }
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  # Users that can access this object, excludes Owner (manager), Admins, AWS Services (IAM)
  members: [String]
    @auth(
      rules: [
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  # Retrieve paperwork from these fields
  # Default limit is 25
  customers(filter: String, limit: Int, nextToken: String): String @function(name: "resolver-${env}")
  contracts(filter: String, limit: Int, nextToken: String): String @function(name: "resolver-${env}")
  employees(filter: String, limit: Int, nextToken: String): String @function(name: "resolver-${env}")
  contractors(filter: String, limit: Int, nextToken: String): String @function(name: "resolver-${env}")
}

# Office details restricted to office owner and WAIS services
type OfficePrivateDetails {
  tin: String!
  professionStartDate: AWSDateTime
  chamberRecordNumber: String
  insuranceLicenseExpirationDate: AWSDateTime
  civilLiabilityExpirationDate: AWSDateTime
  bankAccountInfo: String

  # Store S3 files in this field
  files: [S3Object]
}

type UserProfile
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: owner, ownerField: "username", operations: [read] }
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byEmail", fields: ["email"], queryField: "listUserProfileByEmail")
  @key(name: "byUsername", fields: ["username"], queryField: "listUserProfileByUsername") {
  #Currently the user's username, guaranteed to always be unique
  id: ID

  # Get these on singup via trigger
  username: String!
  email: String!
  telephone: String!

  # Fill this AFTER login
  surname: String
  name: String
  fathers_name: String
  address: String
  zip_code: String
  mobile: String
  tin: String

  # Merged..
  family_name: String
  gender: String
  birthdate: AWSDate
  city: String
  profilePicture: S3Object
  preferences: AWSJSON
  locale: String

  # Store S3 files in this field
  files: [S3Object]

  # Connected with ONE trade if its a STANDARD user or multiple trades if its a CONTRACTOR
  tradeCon: [TradeUserConnection] @connection(keyName: "byUserId", fields: ["id"])

  # Access to pending requests with this user as receiver
  requests: [Requests] @connection(keyName: "byReceiverEmail", fields: ["email"])
}

type Vehicle
  @model(subscriptions: null)
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])
  @key(name: "byTradeName", fields: ["tradeName", "numberPlate"], queryField: "listVehiclesByTradeName")
  @key(name: "byVehicleOwner", fields: ["vehicle_owner", "tradeName"], queryField: "listVehiclesByOwner") {
  id: ID
  numberPlate: String!
  tradeName: String!
  color: String!
  manufacturer: String!
  model: String!
  vehicle_owner: String!
  trim: String!
  fuelType: String
  usage: String!
  displacement: Int!
  eurotax: Int!
  firstRegistrationDate: String!
  passengers: Int!
  purchaseDate: String!
  taxableHorsepower: Int!
  vin: String!
  value: Float!
  file: [S3Object]
}

type Contract
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byTradeName", fields: ["tradeName", "createdAt"], queryField: "listContractsByTradeName")
  @key(name: "byVehicleNumberPlate", fields: ["vehicleNumberPlate", "tradeName"], queryField: "listContractsByVehicleNumberPlates")
  @key(name: "byCustomerId", fields: ["customerId", "tradeName"], queryField: "listContractsByCustomerId") {
  id: ID
  contractId: ID! # Not unique, remember that we keep a history of each contract
  version: Int! # For history
  vehicleNumberPlate: String!
  vehicleId: ID!
  voucherId: String!
  customerId: String!
  tradeName: String!
  second_tradeId: String #Optional
  contractorId: String #Optional
  co_name: String # CoSign participant name (OPTIONAL)
  co_TRN: String # CoSign participant "AFM" (OPTIONAL)
  contractState: String! # Send to S3 on completion
  insuranceClass: String!
  insuranceCoverage: [String]
  insuranceUsage: String
  duration: String!
  creationDate: String!
  startDate: String!
  endDate: String!
  data: String!
  discount: Float! # e.g. 0.1
  jointWorth: Float!
  netWorth: Float!
  driversLicense: DriversLicense
  createdAt: String!
  vehicle: Vehicle @connection(fields: ["vehicleId"])
}

type Customer
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byTradeName", fields: ["tradeName", "firstName", "lastName"], queryField: "listCustomersByTradeName") {
  id: ID
  tin: String!
  tradeName: String!
  firstName: String
  lastName: String
  fathersName: String
  birthDate: String
  gender: String
  email: String!
  mobile: String
  postcode: String
  doy: String
  address: String
  familyStatus: String
  creationDate: AWSTimestamp!
  files: [S3Object]
  driversLicense: DriversLicense
}

type TradeUserConnection
  @model(subscriptions: null)
  @key(name: "byTradeName", fields: ["tradeName", "userId"], queryField: "listTradeUserConnectionsByTradeName")
  @key(name: "byEmployeeType", fields: ["employeeType", "username", "tradeName"], queryField: "listTradeUserConnectionsByEmployeeType")
  @key(name: "byUserId", fields: ["userId", "tradeName"], queryField: "listTradeUserConnectionsByUserId")
  @key(name: "byTradeAndUser", fields: ["tradeName", "username"], queryField: "listTradeUserConnectionsByTradeAndUser")
  @key(name: "byTradeUsername", fields: ["username", "tradeName"], queryField: "listTradeUserConnectionsByUsername")
  @auth(
    rules: [
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
      { allow: owner, ownerField: "members", operations: [read] }
    ]
  ) {
  id: ID
  tradeId: ID!
  tradeName: String!
  userId: ID!
  username: String!
  trade: Office! @connection(fields: ["tradeId"])
  user: UserProfile! @connection(fields: ["userId"]) #User ID and User email are the same
  permissions: [UserPermissions]!
  employeeType: EmployeeType! # e.g Contractor
  preferences: String

  # Usernames that can view this connection (not edit)
  members: [String]!
}

type TradeContractConnection
  @model(subscriptions: null)
  @key(name: "byTradeId", fields: ["tradeId", "tradeName"], queryField: "listTradeContractConnectionByTradeId")
  @key(name: "byTradeName", fields: ["tradeName", "tradeId"], queryField: "listTradeContractConnectionByTradeName")
  @key(name: "byContractId", fields: ["contractId", "tradeId"], queryField: "listTradeContractConnectionByContractId")
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID
  tradeId: ID!
  tradeName: String!
  contractId: ID!
  trade: Office! @connection(fields: ["tradeId"])
  contract: Contract! @connection(fields: ["contractId"])
  ownsContract: Boolean! #If true then the Office can edit the Contract
}

type CompanyAccessConnection
  @model(subscriptions: null)
  @key(name: "byFromId", fields: ["fromId", "toId"], queryField: "listCompanyAccessConnectionByFromId")
  @key(name: "byToId", fields: ["toId", "fromId"], queryField: "listCompanyAccessConnectionByToId")
  @key(name: "byFromTradeName", fields: ["fromTradeName", "toTradeName"], queryField: "listCompanyAccessConnectionByFromTradeName")
  @key(name: "byToTradeName", fields: ["toTradeName", "fromTradeName"], queryField: "listCompanyAccessConnectionByToTradeName")
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID
  fromId: ID!
  fromTradeName: String!
  toId: ID!
  toTradeName: String!
  from: Office! @connection(fields: ["fromId"]) #This trade initiates the collaboration
  to: Office! @connection(fields: ["toId"]) #This trade needs to accept the collaboration
  expirationDate: AWSTimestamp! # Can be used to configure a TTL workflow
  message: String
}

#For callendar use
type UserCalendarEvent
  @model(subscriptions: null)
  @key(name: "byUsername", fields: ["username", "createdAt"], queryField: "listUserCalendarEventsByUsername")
  @auth(rules: [{ allow: owner, ownerField: "username" }, { allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID
  username: String!
  createdAt: String!
  payload: String
}

type TransactionHistory
  @model(subscriptions: null)
  @key(
    name: "bySenderUsername"
    fields: ["senderUsername", "timestamp", "receiverUsername"]
    queryField: "listTransactionHistorybySenderUsername"
  )
  @key(
    name: "byReceiverUsername"
    fields: ["receiverUsername", "timestamp", "senderUsername"]
    queryField: "listTransactionHistorybyReceiverUsername"
  )
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID
  senderUserProfileId: ID!
  receiverUserProfileId: ID!
  timestamp: AWSTimestamp!
  senderUsername: String! # UserProfile ID
  receiverUsername: String!
  transactionAmount: Float!
  sender: UserProfile! @connection(fields: ["senderUserProfileId"])
  receiver: UserProfile! @connection(fields: ["receiverUserProfileId"])
}

type Requests
  @model(subscriptions: null)
  @key(name: "bySenderEmail", fields: ["senderEmail"], queryField: "listRequestsBySenderEmail")
  @key(name: "byReceiverEmail", fields: ["receiverEmail"], queryField: "listRequestsByReceiverEmail")
  @auth(
    rules: [
      { allow: groups, groups: ["admin"] }
      { allow: private, provider: iam }
      { allow: owner, identityClaim: "email", ownerField: "senderEmail", operations: [read, delete] }
      { allow: owner, identityClaim: "email", ownerField: "receiverEmail", operations: [read] }
    ]
  ) {
  id: ID

  # Users involved
  senderUsername: String!
  senderEmail: String!
  receiverEmail: String!

  # Request type and information
  type: RequestType!
  payload: String!

  # Metadata (for AWS services and administrators)
  metadata: String! @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])
}

# ####################################################################################################################################################################################

# Everyone can call this queries
# Authentication is performed inside the lambda resolver
type Query {
  #Utils
  me: String @function(name: "resolver-${env}") @auth(rules: [{ allow: private }])

  user(username: String!): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  echo(msg: String!): String @function(name: "resolver-${env}") @auth(rules: [{ allow: private }])
}

type Mutation {
  # Create / Update / Delete from here
  manageCustomers(action: CustomerResourceAction!, payload: String!): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: private }])
  manageContracts(action: ContractResourceAction!, payload: String!): String
    @function(name: "resolver-${env}") 
    @auth(rules: [{ allow: private }])
  manageEmployees(action: EmployeeResourceAction!, payload: String!): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: private }])
  manageContractors(action: ContractorResourceAction!, payload: String!): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: private }])

  # Attempt to update fields in this object,
  # 'typename' is the @model-Type as described in this file. Case sensitive. (eg. 'UserProfile')
  # 'id' The entry ID.
  # 'fields' is an array of dictionaries with attribute names as keys and attribute values with field values
  # Output is a JSON style map with attributes as keys and a boolean value that indicates wether an attribute changed or not
  # EXAMPLE: Input  -> [{"logo": "s3://..." } , { "tin": "..." }]
  #          Output -> [{"logo": "true} , {"tin":"false"}]
  updateFields(typename: String!, id: ID!, fields: String): String @function(name: "resolver-${env}") @auth(rules: [{ allow: private }])

  # Update user balance
  sendMoneyToUserWithUsername(receiverUsername: String, amount: Float!): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: private }])

  # Request API
  sendRequest(requestType: RequestType!, payload: String!): String @function(name: "resolver-${env}") @auth(rules: [{ allow: private }])
  resolveRequest(id: ID!, payload: String!): String @function(name: "resolver-${env}") @auth(rules: [{ allow: private }])
}

# ###################### ENUMS/TYPES ######################

# CRUD specififc types
enum CustomerResourceAction {
  TODO
}
enum EmployeeResourceAction {
  UPDATE_PERMISSIONS
  REMOVE
}
enum ContractorResourceAction {
  TODO
}
enum ContractResourceAction {
  TODO
}

enum RequestType {
  CREATE_TRADE
  CREATE_COMPANY_CONNECTION
  INVITE_EMPLOYEE_TO_OFFICE
  INVITE_CONTRACTOR_TO_OFFICE
}

# Employee management API
enum EmployeeAction {
  UPDATE_PERMISSIONS # Overwrites the user's permissions iff they exist in the 'members' field
  REMOVE # Remove user, permissions field is ignored and thus can be omitted
}

# Standard CRUD general purpose enum
enum CRUD_ACTION {
  CREATE
  REMOVE
  UPDATE
  DELETE
}

#Add all department-specific
type UserPermissions {
  department: String #User defined
  read: Boolean
  write: Boolean
}
type S3Object {
  bucket: String!
  region: String!
  key: String!
  name: String!
}

enum EmployeeType {
  STANDARD
  CONTRACTOR
  MANAGER
}

type DriversLicense {
  LicenseID: Int
  DriversLicenseType: String # Erasitexniko/Epaggelmatiko
  Category: [DriversLicenseCategory]
}

type DriversLicenseCategory {
  category: String
  issueDate: String
  expiresAt: String
}

type InsurancePackage {
  name: String!
  insuranceClass: String!
  coverage: [String]
  usages: String
}
type Value {
  Name: String!
  Value: String
}
type MFAOption {
  DeliveryMedium: String
  AttributeName: String
}
enum UserStatus {
  UNCONFIRMED
  CONFIRMED
  ARCHIVED
  COMPROMISED
  UNKNOWN
  RESET_REQUIRED
  FORCE_CHANGE_PASSWORD
}

enum ConnectionStatus {
  ACCEPTED
  REJECTED
}
