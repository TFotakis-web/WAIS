# Each office has one owner and each owner hast one office, always!
type Office
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: owner, ownerField: "ownerUsername", operations: [read, update] }
      { allow: owner, ownerField: "members", operations: [read] }
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byTradeName", fields: ["tradeName", "ownerUsername"], queryField: "listTradeByName")
  @key(name: "byOwnerUsername", fields: ["ownerUsername", "tradeName"], queryField: "listTradeByOwnerUsername") {
  # Restrict to READ_ONLY
  id: ID!
    @auth(
      rules: [
        { allow: owner, ownerField: "ownerUsername", operations: [read] }
        { allow: owner, ownerField: "members", operations: [read] }
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  # Info
  tradeName: String!
  ownerUsername: String!
  ownerId: ID!
  tin: String!
  logo: String!
  info: String!
  postcode: String!

  # The amount of employees (or contractors) left that can join this Office
  remainingMembersAllowed: Int!
    @auth(
      rules: [
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  # Users that can access this object (excluding Admins/Lambdas)
  members: [String]!
    @auth(
      rules: [
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  #Owner's UserProfile
  ownerProfile: UserProfile @connection(fields: ["ownerId"]) @auth(rules: [{ allow: owner, ownerField: "members", operations: [] }])

  # Segregated CRUD API since filter/limit/nextToken should only apply to Reads, also payload is not needed
  # Retrieve everything from here
  customers(filter: String, limit: Int, nextToken: String): String @function(name: "resolver-${env}")
  contracts(filter: String, limit: Int, nextToken: String): String @function(name: "resolver-${env}")
  employees(filter: String, limit: Int, nextToken: String): String @function(name: "resolver-${env}")
  contractors(filter: String, limit: Int, nextToken: String): String @function(name: "resolver-${env}")

  # Create / Update / Delete from here
  manageCustomers(action: CustomerResourceAction!, payload: String!): String @function(name: "resolver-${env}")
  manageContracts(action: ContractResourceAction!, payload: String!): String @function(name: "resolver-${env}")
  manageEmployees(action: EmployeeResourceAction!, payload: String!): String @function(name: "resolver-${env}")
  manageContractors(action: ContractorResourceAction!, payload: String!): String @function(name: "resolver-${env}")
}

type UserProfile
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: owner, ownerField: "username", operations: [read, update] }
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byEmail", fields: ["email"], queryField: "listUserProfileByEmail")
  @key(name: "byUsername", fields: ["username"], queryField: "listUserProfileByUsername") {
  #Currently the user's email, guaranteed to always be unique
  id: ID!
    @auth(
      rules: [
        { allow: owner, ownerField: "username", operations: [read] }
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  # Cognito verified username/email pair, unique at all times.
  username: String!
  email: String!

  #Various info
  telephone: String!
  tin: String
  doy: String
  familyStatus: String
  chamberRecordNumber: String
  insuranceLicenseExpirationDate: AWSDateTime
  partnersNumberLimit: Int
  professionStartDate: AWSDateTime
  file: [S3Object]

  # Connected with ONE trade if its a STANDARD user or multiple trades if its a CONTRACTOR
  tradeCon: [TradeUserConnection] @connection(keyName: "byUserId", fields: ["id"])

  # Access to user's wallet
  wallet: UserWallet @connection(fields: ["id"])

  # Access to pending requests with this user as receiver
  requests: [Requests] @connection(keyName: "byReceiverEmail", fields: ["email"])
}

type Vehicle
  @model(subscriptions: null)
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])
  @key(name: "byTradeName", fields: ["tradeName", "numberPlate"], queryField: "listVehiclesByTradeName")
  @key(name: "byVehicleOwner", fields: ["vehicle_owner", "tradeName"], queryField: "listVehiclesByOwner") {
  id: ID!
  numberPlate: String!
  tradeName: String!
  color: String!
  manufacturer: String!
  model: String!
  vehicle_owner: String!
  trim: String!
  fuelType: String
  usage: String!
  displacement: Int!
  eurotax: Int!
  firstRegistrationDate: String!
  passengers: Int!
  purchaseDate: String!
  taxableHorsepower: Int!
  vin: String!
  value: Float!
  file: [S3Object]
}

type Contract
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byTradeName", fields: ["tradeName", "createdAt"], queryField: "listContractsByTradeName")
  @key(name: "byVehicleNumberPlate", fields: ["vehicleNumberPlate", "tradeName"], queryField: "listContractsByVehicleNumberPlates")
  @key(name: "byCustomerId", fields: ["customerId", "tradeName"], queryField: "listContractsByCustomerId") {
  id: ID!
  contractId: ID! # Not unique, remember that we keep a history of each contract
  version: Int! # For history
  vehicleNumberPlate: String!
  vehicleId: ID!
  voucherId: String!
  customerId: String!
  tradeName: String!
  second_tradeId: String #Optional
  contractorId: String #Optional
  co_name: String # CoSign participant name (OPTIONAL)
  co_TRN: String # CoSign participant "AFM" (OPTIONAL)
  contractState: String! # Send to S3 on completion
  insuranceClass: String!
  insuranceCoverage: [String]
  insuranceUsage: String
  duration: String!
  creationDate: String!
  startDate: String!
  endDate: String!
  data: String!
  discount: Float! # e.g. 0.1
  jointWorth: Float!
  netWorth: Float!
  driversLicense: DriversLicense
  createdAt: String!
  vehicle: Vehicle @connection(fields: ["vehicleId"])
}

type Customer
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byTradeName", fields: ["tradeName", "firstName", "lastName"], queryField: "listCustomersByTradeName") {
  id: ID!
  tin: String!
  tradeName: String!
  firstName: String
  lastName: String
  fathersName: String
  birthDate: String
  gender: String
  email: String!
  mobile: String
  postcode: String
  doy: String
  address: String
  familyStatus: String
  creationDate: AWSTimestamp!
  files: [S3Object]
  driversLicense: DriversLicense
}

type TradeUserConnection
  @model(subscriptions: null)
  @key(name: "byTradeName", fields: ["tradeName", "userId"], queryField: "listTradeUserConnectionsByTradeName")
  @key(name: "byEmployeeType", fields: ["employeeType"], queryField: "listTradeUserConnectionsByEmployeeType")
  @key(name: "byUserId", fields: ["userId", "tradeName"], queryField: "listTradeUserConnectionsByUserId")
  @key(name: "byTradeAndUser", fields: ["tradeName", "username"], queryField: "listTradeUserConnectionsByTradeAndUser")
  @key(name: "byTradeUsername", fields: ["username", "tradeName"], queryField: "listTradeUserConnectionsByUsername")
  @auth(
    rules: [
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
      { allow: owner, ownerField: "members", operations: [read] }
    ]
  ) {
  id: ID!
  tradeId: ID!
  tradeName: String!
  userId: ID!
  username: String!
  trade: Office! @connection(fields: ["tradeId"])
  user: UserProfile! @connection(fields: ["userId"]) #User ID and User email are the same
  permissions: [UserPermissions]
  employeeType: EmployeeType! # e.g Contractor
  preferences: String

  # Usernames that can view this connection (not edit)
  members: [String]!

  #Extras
  createdAt: AWSDateTime!
}

type TradeContractConnection
  @model(subscriptions: null)
  @key(name: "byTradeId", fields: ["tradeId", "tradeName"], queryField: "listTradeContractConnectionByTradeId")
  @key(name: "byTradeName", fields: ["tradeName", "tradeId"], queryField: "listTradeContractConnectionByTradeName")
  @key(name: "byContractId", fields: ["contractId", "tradeId"], queryField: "listTradeContractConnectionByContractId")
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID!
  tradeId: ID!
  tradeName: String!
  contractId: ID!
  trade: Office! @connection(fields: ["tradeId"])
  contract: Contract! @connection(fields: ["contractId"])
  ownsContract: Boolean! #If true then the Office can edit the Contract
}

type CompanyAccessConnection
  @model(subscriptions: null)
  @key(name: "byFromId", fields: ["fromId", "toId"], queryField: "listCompanyAccessConnectionByFromId")
  @key(name: "byToId", fields: ["toId", "fromId"], queryField: "listCompanyAccessConnectionByToId")
  @key(name: "byFromTradeName", fields: ["fromTradeName", "toTradeName"], queryField: "listCompanyAccessConnectionByFromTradeName")
  @key(name: "byToTradeName", fields: ["toTradeName", "fromTradeName"], queryField: "listCompanyAccessConnectionByToTradeName")
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID!
  fromId: ID!
  fromTradeName: String!
  toId: ID!
  toTradeName: String!
  from: Office! @connection(fields: ["fromId"]) #This trade initiates the collaboration
  to: Office! @connection(fields: ["toId"]) #This trade needs to accept the collaboration
  expirationDate: AWSTimestamp! # Can be used to configure a TTL workflow
  message: String!
}

#For callendar use
type UserCalendarEvent
  @model(subscriptions: null)
  @auth(rules: [{ allow: owner, ownerField: "username" }, { allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID!
  username: String!
  createdAt: String!
  payload: String
}

type UserWallet
  @model(subscriptions: null)
  @key(name: "byUsername", fields: ["username"], queryField: "listUserWalletByUsername")
  @auth(
    rules: [
      { allow: owner, operations: [read], ownerField: "username" }
      { allow: groups, groups: ["admin"] }
      { allow: private, provider: iam }
    ]
  ) {
  id: ID!
  username: String!
  balance: Float!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type TransactionHistory
  @model(subscriptions: null)
  @key(
    name: "bySenderUsername"
    fields: ["senderUsername", "timestamp", "receiverUsername"]
    queryField: "listTransactionHistorybySenderUsername"
  )
  @key(
    name: "byReceiverUsername"
    fields: ["receiverUsername", "timestamp", "senderUsername"]
    queryField: "listTransactionHistorybyReceiverUsername"
  )
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID!
  senderUserProfileId: ID!
  receiverUserProfileId: ID!
  timestamp: AWSTimestamp!
  senderUsername: String! # UserProfile ID
  receiverUsername: String!
  transactionAmount: Float!
  sender: UserProfile! @connection(fields: ["senderUserProfileId"])
  receiver: UserProfile! @connection(fields: ["receiverUserProfileId"])
  senderWallet: UserWallet! @connection(fields: ["senderUserProfileId"])
  receiverWallet: UserWallet! @connection(fields: ["receiverUserProfileId"])
}

type Requests
  @model(subscriptions: null)
  @key(name: "bySenderEmail", fields: ["senderEmail"], queryField: "listRequestsBySenderEmail")
  @key(name: "byReceiverEmail", fields: ["receiverEmail"], queryField: "listRequestsByReceiverEmail")
  @auth(
    rules: [
      { allow: groups, groups: ["admin"] }
      { allow: private, provider: iam }
      { allow: owner, identityClaim: "email", ownerField: "senderEmail", operations: [read, delete] }
      { allow: owner, identityClaim: "email", ownerField: "receiverEmail", operations: [read] }
    ]
  ) {
  id: ID!
  expiresAt: AWSTimestamp!

  # Users involved
  senderUsername: String!
  senderEmail: String!
  receiverEmail: String!

  # Request type and information
  type: RequestType!
  payload: String!

  # Metadata (for AWS services and administrators)
  metadata: String! @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])
}

# ####################################################################################################################################################################################

# Everyone can call this queries
# Authentication is performed inside the lambda resolver
type Query {
  #Utils
  me: String @function(name: "resolver-${env}") @auth(rules: [{ allow: private }])

  user(username: String!): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  echo(msg: String!): String @function(name: "resolver-${env}") @auth(rules: [{ allow: private }])

  # Request API
  sendRequest(requestType: RequestType!, payload: String!): String @function(name: "resolver-${env}") @auth(rules: [{ allow: private }])
  resolveRequest(id: ID!, payload: String!): String @function(name: "resolver-${env}") @auth(rules: [{ allow: private }])
}

type Mutation {
  # Update user balance
  sendMoneyToUserWithUsername(receiverUsername: String, amount: Float!): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: private }])
}

# ###################### ENUMS/TYPES ######################

# CRUD specififc types
enum CustomerResourceAction {
  TODO
}
enum EmployeeResourceAction {
  UPDATE_PERMISSIONS
  REMOVE
}
enum ContractorResourceAction {
  TODO
}
enum ContractResourceAction {
  TODO
}

enum RequestType {
  CREATE_TRADE
  CREATE_COMPANY_CONNECTION
  INVITE_EMPLOYEE_TO_OFFICE
  INVITE_CONTRACTOR_TO_OFFICE
}

# Employee management API
enum EmployeeAction {
  UPDATE_PERMISSIONS # Overwrites the user's permissions iff they exist in the 'members' field
  REMOVE # Remove user, permissions field is ignored and thus can be omitted
}

#Add all department-specific
type UserPermissions {
  department: String #User defined
  read: Boolean
  write: Boolean
}
type S3Object {
  bucket: String!
  region: String!
  key: String!
  name: String!
}

enum EmployeeType {
  STANDARD
  CONTRACTOR
}

type DriversLicense {
  LicenseID: Int
  DriversLicenseType: String # Erasitexniko/Epaggelmatiko
  Category: [DriversLicenseCategory]
}

type DriversLicenseCategory {
  category: String
  issueDate: String
  expiresAt: String
}

type InsurancePackage {
  name: String!
  insuranceClass: String!
  coverage: [String]
  usages: String
}
type Value {
  Name: String!
  Value: String
}
type MFAOption {
  DeliveryMedium: String
  AttributeName: String
}
enum UserStatus {
  UNCONFIRMED
  CONFIRMED
  ARCHIVED
  COMPROMISED
  UNKNOWN
  RESET_REQUIRED
  FORCE_CHANGE_PASSWORD
}

enum ConnectionStatus {
  ACCEPTED
  REJECTED
}

# Used to model a Cognito user, not a 'real' DynamoDB type
# type UserCognito {
#   id: ID! # Custom attribute
#   name: String! # Full Name (includes middle name)
#   given_name: String! # First name
#   family_name: String! # Surname
#   middle_name: String! # Father's name!
#   preferred_username: String!
#   picture: String!
#   email: String!
#   email_verified: Boolean!
#   gender: String!
#   birthdate: String!
#   locale: String!
#   phone_number: String!
#   phone_number_verified: Boolean!
#   address: AWSJSON! # Specific json, check https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims
#   updated_at: AWSDateTime!
# }
