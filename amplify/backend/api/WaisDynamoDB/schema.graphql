type Trade @model(subscriptions: null) @auth(rules: [{ allow: groups, groups: ["admin"] }]) @key(name: "byName", fields: ["tradeName", "id"]) {
  # Immutable UID
  id: ID!
  # Trade details
  tradeName: String!
  tin: String!
  logo: AWSURL!
  info: String!
  postcode: String!
  ownerId: ID!
  # HR
  owner: UserProfile @connection(fields: ["ownerId"])
  employees: [TradeUserConnection] @connection(keyName: "byTradeId", fields: ["id"])
  contractors: [TradeUserConnection] @connection(keyName: "byTradeId", fields: ["id"])
  customers: [Customer] @connection(keyName: "byTradeId", fields: ["id"])
  contracts: [Contract] @connection(keyName: "byTradeId", fields: ["id"])
  # Connections
  fromCompanyAccess: [CompanyAccessConnection] @connection(keyName: "byFromId", fields: ["id"]) # Accesses requested by this trade
  toCompanyAccess: [CompanyAccessConnection] @connection(keyName: "byToId", fields: ["id"]) #  Accesses made by others to this trade
}

type UserProfile @model(subscriptions: null) @auth(rules: [{ allow: owner, ownerField: "id", identityClaim: "id", operations: [read] }, { allow: groups, groups: ["admin"] }]) @key(name: "byUsername", fields: ["username", "id"]) {
  #Redudant fields, keep them to avoid multiple queries
  id: ID!
  username: String!

  #Unique fields, not present anywhere eles
  telephone: String
  tin: Int!
  doy: String!
  familyStatus: String!
  chamberRecordNumber: String!
  insuranceLicenseExpirationDate: AWSTimestamp! @ttl
  partnersNumberLimit: Int!
  professionStartDate: String!
  file: [File]

  # Connected with ONE trade if its a STANDARD user or multiple trades if its a CONTRACTOR
  tradeCon: [TradeUserConnection] @auth(rules: [{ allow: groups, groups: ["admin"] }]) @connection(keyName: "byUserId", fields: ["id"])
}

type Vehicle @model(subscriptions: null) @auth(rules: [{ allow: groups, groups: ["admin"] }]) @key(name: "byTradeId", fields: ["tradeId", "id"]) {
  id: ID!
  tradeId: ID!
  contractId: ID!
  numberPlate: String!
  color: String!
  manufacturer: String!
  model: String!
  owner: String!
  trim: String!
  fuelType: String
  usage: String!
  displacement: Int!
  eurotax: Int!
  firstRegistrationDate: String!
  passengers: Int!
  purchaseDate: String!
  taxableHorsepower: Int!
  vin: String!
  value: Float!
  file: [File]
  contract: Contract @connection(fields: ["contractId"])
}

# All fields in this type MUST be immutable
type Contract @model(subscriptions: null) @auth(rules: [{ allow: owner }, { allow: groups, groups: ["admin"] }]) @key(name: "byTradeId", fields: ["tradeId", "id"]) @key(name: "byCustomerId", fields: ["customerId", "id"]) {
  #Unique IDs
  id: ID!
  voucherId: ID!
  vehicleId: ID!
  customerId: ID!
  tradeId: ID!

  contractState: String! # Send to S3 on completion
  tradeAdmin: String! #Aftos poy kanei amesa to insurance
  assignee: String! #Aftos poy kanei emesa to insurance
  partner: String!
  company: String!
  insuranceClass: String!
  insuranceCoverage: [String]
  insuranceUsage: String

  duration: String!
  creationDate: String!
  startDate: String!
  endDate: String!
  data: String!
  discount: Float! # e.g. 0.1
  jointWorth: Float!
  netWorth: Float!
  driversLicense: DriversLicense

  #Connections
  vehicle: Vehicle @connection(fields: ["vehicleId"])
  customer: Customer @connection(fields: ["customerId"])
  trade: Trade @connection(fields: ["tradeId"])

  #Participants
}

type Customer @model(subscriptions: null) @auth(rules: [{ allow: owner }, { allow: groups, groups: ["admin"] }]) @key(name: "byEmail", fields: ["email", "name"]) @key(name: "byTradeId", fields: ["tradeId", "name"]) {
  id: ID!
  tradeId: ID!
  tin: Int
  name: String
  surname: String
  fathersName: String
  birthDate: String
  gender: String
  email: String
  mobile: String
  postcode: String
  doy: String
  address: String
  familyStatus: String
  creationDate: AWSTimestamp!
  files: [File]
  driversLicense: DriversLicense
  trade: Trade @connection(fields: ["tradeId"])
}

type TradeUserConnection @model(subscriptions: null) @key(name: "byTradeId", fields: ["tradeId", "userId"]) @key(name: "byUserId", fields: ["userId", "tradeId"]) @auth(rules: [{ allow: groups, groups: ["admin"] }]) {
  id: ID!
  tradeId: ID!
  userId: ID! #Owner ID of the UserProfile
  trade: Trade! @connection(fields: ["tradeId"])
  user: UserProfile! @connection(fields: ["userId"])
  permissions: [UserPermissions]
  preferences: String
}

type CompanyAccessConnectionRequest @model(subscriptions: null) @key(name: "byFromId", fields: ["fromId", "toId"]) @key(name: "byToId", fields: ["toId", "fromId"]) @auth(rules: [{ allow: groups, groups: ["admin"] }]) {
  id: ID!
  fromId: ID!
  toId: ID!
  from: Trade! @connection(fields: ["fromId"]) #This trade initiates the collaboration
  to: Trade! @connection(fields: ["toId"]) #This trade needs to accept the collaboration
  expirationDate: AWSTimestamp! @ttl # Can be used to configure a TTL workflow
  message: String!
}

type CompanyAccessConnection @model(subscriptions: null) @key(name: "byFromId", fields: ["fromId", "toId"]) @key(name: "byToId", fields: ["toId", "fromId"]) @auth(rules: [{ allow: groups, groups: ["admin"] }]) {
  id: ID!
  fromId: ID!
  toId: ID!
  from: Trade! @connection(fields: ["fromId"]) #This trade initiates the collaboration
  to: Trade! @connection(fields: ["toId"]) #This trade needs to accept the collaboration
  expirationDate: AWSTimestamp! @ttl # Can be used to configure a TTL workflow
  message: String!
}
#Add all department-specific
type UserPermissions {
  department: String #User defined
  read: Boolean
  write: Boolean
}

# consider an id
type File {
  name: String
  url: AWSURL
}

enum EmployeeType {
  STANDARD
  CONTRACTOR
}

type DriversLicense {
  LicenseID: Int
  DriversLicenseType: String # Erasitexniko/Epaggelmatiko
  Category: [DriversLicenseCategory]
}

type DriversLicenseCategory {
  category: String
  issueDate: String
  expiresAt: String
}

type InsurancePackage {
  name: String!
  insuranceClass: String!
  coverage: [String]
  usages: String
}

#For callendar use
type UserCalendarEvent @model(subscriptions: null) @auth(rules: [{ allow: owner, ownerField: "id", identityClaim: "sub" }, { allow: groups, groups: ["admin"] }]) {
  id: ID!
  userId: String! # Cognito ID
  username: String!
  createdAt: String!
  payload: String
}

# ####################################################################################################################################################################################

# These types derived from https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/CognitoIdentityServiceProvider.html#adminGetUser-property
type Query {
  me: User @function(name: "ResolverFunction-${env}")
  user(username: String): User @function(name: "ResolverFunction-${env}")
  echo(msg: String): String @function(name: "ResolverFunction-${env}")
}

type User {
  Username: String!
  UserAttributes: [Value]
  UserCreateDate: String
  UserLastModifiedDate: String
  Enabled: Boolean
  UserStatus: UserStatus
  MFAOptions: [MFAOption]
  PreferredMfaSetting: String
  UserMFASettingList: String
}
type Value {
  Name: String!
  Value: String
}
type MFAOption {
  DeliveryMedium: String
  AttributeName: String
}
enum UserStatus {
  UNCONFIRMED
  CONFIRMED
  ARCHIVED
  COMPROMISED
  UNKNOWN
  RESET_REQUIRED
  FORCE_CHANGE_PASSWORD
}

type TestType @model @auth(rules: [{ allow: private }]) {
  id: ID
  val: String!
}

# Used to model a Cognito user, not a 'real' DynamoDB type
# type UserCognito {
#   id: ID! # Custom attribute
#   name: String! # Full Name (includes middle name)
#   given_name: String! # First name
#   family_name: String! # Surname
#   middle_name: String! # Father's name!
#   preferred_username: String!
#   picture: String!
#   email: String!
#   email_verified: Boolean!
#   gender: String!
#   birthdate: String!
#   locale: String!
#   phone_number: String!
#   phone_number_verified: Boolean!
#   address: AWSJSON! # Specific json, check https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims
#   updated_at: AWSDateTime!
# }
