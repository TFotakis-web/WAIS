type Office
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: owner, ownerField: "ownerUsername", operations: [read, update] }
      { allow: owner, ownerField: "members", operations: [read] }
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byTradeName", fields: ["tradeName", "ownerUsername"], queryField: "listTradeByName")
  @key(name: "byOwnerUsername", fields: ["ownerUsername", "tradeName"], queryField: "listTradeByOwnerUsername") {
  id: ID!
  tradeName: String!
  ownerUsername: String!
  ownerId: ID!
  tin: String!
  logo: String!
  info: String!
  postcode: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!

  # The amount of employees (or contractors) left that can join this Office
  remainingMembersAllowed: Int!
    @auth(
      rules: [
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  # Users that can access this object (excluding Admins/Lambdas)
  members: [String]!
    @auth(
      rules: [
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
      ]
    )

  #Owner's UserProfile
  ownerProfile: UserProfile @connection(fields: ["ownerId"]) @auth(rules: [{ allow: owner, ownerField: "members", operations: [] }])

  # Paperwork
  # Response structure: {"items":[...],"nextToken":"..."}
  customers(filter: String, limit: Int, nextToken: String): String @function(name: "resolver-${env}")
  contracts(filter: String, limit: Int, nextToken: String): String @function(name: "resolver-${env}")
  employees(filter: String, limit: Int, nextToken: String): String @function(name: "resolver-${env}")
  contractors(filter: String, limit: Int, nextToken: String): String @function(name: "resolver-${env}")
}
type UserProfile
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: owner, ownerField: "username", operations: [read, update] }
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byUsername", fields: ["username", "createdAt"], queryField: "listUserProfileByUsername")
  @key(name: "byDoy", fields: ["doy", "createdAt"], queryField: "listUserProfileByDoy") {
  # Important field(s)
  id: ID!
  username: String!

  #Unique fields, not present anywhere eles
  telephone: String!
  tin: String!
  doy: String!
  familyStatus: String!
  chamberRecordNumber: String!
  insuranceLicenseExpirationDate: AWSDateTime!
  partnersNumberLimit: Int!
  professionStartDate: AWSDateTime!
  file: [S3Object]

  #Extras
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!

  # Connected with ONE trade if its a STANDARD user or multiple trades if its a CONTRACTOR
  tradeCon: [TradeUserConnection]
    @connection(keyName: "byUserName", fields: ["username"])
    @auth(
      rules: [
        { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
        { allow: private, provider: iam, operations: [create, read, update, delete] }
        { allow: owner, ownerField: "username", operations: [read] }
      ]
    )
}

type Vehicle
  @model(subscriptions: null)
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])
  @key(name: "byTradeName", fields: ["tradeName", "numberPlate"], queryField: "listVehicleByTradeName")
  @key(name: "byVehicleOwner", fields: ["vehicle_owner", "tradeName"], queryField: "listVehiclesByOwner") {
  id: ID!
  numberPlate: String!
  tradeName: String!
  color: String!
  manufacturer: String!
  model: String!
  vehicle_owner: String!
  trim: String!
  fuelType: String
  usage: String!
  displacement: Int!
  eurotax: Int!
  firstRegistrationDate: String!
  passengers: Int!
  purchaseDate: String!
  taxableHorsepower: Int!
  vin: String!
  value: Float!
  file: [S3Object]
}

type Contract
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byTradeName", fields: ["tradeName", "createdAt"], queryField: "listContractsByTradeName")
  @key(name: "byVehicleNumberPlate", fields: ["vehicleNumberPlate", "tradeName"], queryField: "listContractsByVehicleNumberPlates")
  @key(name: "byCustomerId", fields: ["customerId", "tradeName"], queryField: "listContractsByCustomerId") {
  id: ID!
  contractId: ID! # Not unique, remember that we keep a history of each contract
  version: Int! # For history
  vehicleNumberPlate: String!
  vehicleId: ID!
  voucherId: String!
  customerId: String!
  tradeName: String!
  second_tradeId: String #Optional
  contractorId: String #Optional
  co_name: String # CoSign participant name (OPTIONAL)
  co_TRN: String # CoSign participant "AFM" (OPTIONAL)
  contractState: String! # Send to S3 on completion
  insuranceClass: String!
  insuranceCoverage: [String]
  insuranceUsage: String
  duration: String!
  creationDate: String!
  startDate: String!
  endDate: String!
  data: String!
  discount: Float! # e.g. 0.1
  jointWorth: Float!
  netWorth: Float!
  driversLicense: DriversLicense
  createdAt: String!
  vehicle: Vehicle @connection(fields: ["vehicleId"])
}

type Customer
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
    ]
  )
  @key(name: "byTradeName", fields: ["tradeName", "firstName", "lastName"]) {
  id: ID!
  tin: String!
  tradeName: String!
  firstName: String
  lastName: String
  fathersName: String
  birthDate: String
  gender: String
  email: String!
  mobile: String
  postcode: String
  doy: String
  address: String
  familyStatus: String
  creationDate: AWSTimestamp!
  files: [S3Object]
  driversLicense: DriversLicense
}

type TradeUserConnection
  @model(subscriptions: null)
  @key(name: "byTradeName", fields: ["tradeName", "username"], queryField: "listTradeUserConnectionsByTradeName")
  @key(name: "byEmployeeType", fields: ["employeeType", "username"], queryField: "listTradeUserConnectionsByEmployeeType")
  @key(name: "byUserName", fields: ["username", "tradeName"], queryField: "listTradeUserConnectionsByUserName")
  @auth(
    rules: [
      { allow: groups, groups: ["admin"], operations: [create, read, update, delete] }
      { allow: private, provider: iam, operations: [create, read, update, delete] }
      { allow: owner, ownerField: "username", operations: [read] }
    ]
  ) {
  id: ID!
  tradeId: ID!
  tradeName: String!
  userId: ID!
  username: String!
  trade: Office! @connection(fields: ["tradeId"])
  user: UserProfile! @connection(fields: ["userId"])
  permissions: [UserPermissions]
  employeeType: EmployeeType! # e.g Contractor
  preferences: String

  #Extras
  createdAt: AWSDateTime!
}

type CompanyAccessConnectionRequest
  @model(subscriptions: null)
  @key(name: "byMessage", fields: ["message", "createdAt"])
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID!
  fromId: ID!
  toId: ID!
  from: Office! @connection(fields: ["fromId"]) #This trade initiates the collaboration
  to: Office! @connection(fields: ["toId"]) #This trade needs to accept the collaboration
  expirationDate: AWSTimestamp! # Can be used to configure a TTL workflow
  message: String!
  createdAt: AWSDateTime!
}

type TradeContractConnection
  @model(subscriptions: null)
  @key(name: "byTradeId", fields: ["tradeId", "tradeName"])
  @key(name: "byTradeName", fields: ["tradeName", "tradeId"])
  @key(name: "byContractId", fields: ["contractId", "tradeId"])
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID!
  tradeId: ID!
  tradeName: String!
  contractId: ID!
  trade: Office! @connection(fields: ["tradeId"])
  contract: Contract! @connection(fields: ["contractId"])
  ownsContract: Boolean! #If true then the Office can edit the Contract
}

type CompanyAccessConnection
  @model(subscriptions: null)
  @key(name: "byFromId", fields: ["fromId", "toId"])
  @key(name: "byToId", fields: ["toId", "fromId"])
  @key(name: "byFromTradeName", fields: ["fromTradeName", "toTradeName"])
  @key(name: "byToTradeName", fields: ["toTradeName", "fromTradeName"])
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID!
  fromId: ID!
  fromTradeName: String!
  toId: ID!
  toTradeName: String!
  from: Office! @connection(fields: ["fromId"]) #This trade initiates the collaboration
  to: Office! @connection(fields: ["toId"]) #This trade needs to accept the collaboration
  expirationDate: AWSTimestamp! # Can be used to configure a TTL workflow
  message: String!
}

#For callendar use
type UserCalendarEvent
  @model(subscriptions: null)
  @auth(rules: [{ allow: owner, ownerField: "username" }, { allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID!
  username: String!
  createdAt: String!
  payload: String
}

type UserWallet
  @model(subscriptions: null)
  @key(name: "byUsername", fields: ["username"])
  @auth(
    rules: [
      { allow: owner, operations: [read], ownerField: "username" }
      { allow: groups, groups: ["admin"] }
      { allow: private, provider: iam }
    ]
  ) {
  id: ID!
  username: String!
  balance: Float!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type TransactionHistory
  @model(subscriptions: null)
  @key(name: "bySenderUsername", fields: ["senderUsername", "timestamp", "receiverUsername"])
  @key(name: "byReceiverUsername", fields: ["receiverUsername", "timestamp", "senderUsername"])
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID!
  senderUserProfileId: ID!
  receiverUserProfileId: ID!
  timestamp: AWSTimestamp!
  senderUsername: String! # UserProfile ID
  receiverUsername: String!
  transactionAmount: Float!
  sender: UserProfile! @connection(fields: ["senderUserProfileId"])
  receiver: UserProfile! @connection(fields: ["receiverUserProfileId"])
  senderWallet: UserWallet! @connection(fields: ["senderUserProfileId"])
  receiverWallet: UserWallet! @connection(fields: ["receiverUserProfileId"])
}

type AdminRequests
  @model(subscriptions: null)
  @key(name: "byTradeId", fields: ["tradeId"])
  @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }]) {
  id: ID!
  expiresAt: AWSTimestamp!
  message: String!
  userId: ID!
  profile: UserProfile! @connection(fields: ["userId"])

  #Request fields
  tradeId: ID!
  tradeName: String!
  logo: String
  info: String!
  tin: String!
  postcode: String!
}

# ####################################################################################################################################################################################

# Everyone can call this queries
# Authentication is performed inside the lambda resolver
type Query {
  #Utils
  me: User @function(name: "resolver-${env}") @auth(rules: [{ allow: private }])

  user(username: String!): User
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  echo(msg: String!): String @function(name: "resolver-${env}") @auth(rules: [{ allow: private }])

  #Admin API
  requestAdminAproval(tradeName: String!, message: String!): String @function(name: "resolver-${env}") @auth(rules: [{ allow: private }]) #Returns the request ID
  adminAproveRequest(id: String!): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])
}

type Mutation {
  #Paperwork
  createOrUpdateContract(contract: String): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  #Manage company connections
  createCompanyConnectionRequest(email: String): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  replyToCompanyConnectionRequest(id: ID, status: ConnectionStatus): ConnectionStatus
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  # Office user management
  manageOfficeEmployee(username: String!, action: EmployeeAction!, permissions: [UserPermissionsInput]!, tradeName: String!): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: groups, groups: ["admin"] }, { allow: private, provider: iam }])

  # Update user balance
  sendMoneyToUserWithUsername(receiverUsername: String, amount: Float!): String
    @function(name: "resolver-${env}")
    @auth(rules: [{ allow: private }])

  #CRUD
  manageCustomers(customer: String!, action: CRUDAction!): String @function(name: "resolver-${env}") @auth(rules: [{ allow: private }])
  manageContracts(contract: String!, action: CRUDAction!): String @function(name: "resolver-${env}") @auth(rules: [{ allow: private }])
  manageEmployees(employee: String!, action: CRUDAction!): String @function(name: "resolver-${env}") @auth(rules: [{ allow: private }])
}

# ###################### ENUMS/TYPES ######################

# CRUD specififc types
enum CRUDAction {
  CREATE
  UPDATE
  DELETE
}

input UserPermissionsInput {
  department: String
  read: Boolean
  write: Boolean
}

# Employee management API
enum EmployeeAction {
  INSERT # Creates user with the given permissions if they dont exist
  UPDATE # Overwrites the user's permissions iff they exist in members
  DELETE # Remove user, permissions field is ignored and thus can be omitted
}

#Add all department-specific
type UserPermissions {
  department: String #User defined
  read: Boolean
  write: Boolean
}
type S3Object {
  bucket: String!
  region: String!
  key: String!
  name: String!
}

enum EmployeeType {
  STANDARD
  CONTRACTOR
}

type DriversLicense {
  LicenseID: Int
  DriversLicenseType: String # Erasitexniko/Epaggelmatiko
  Category: [DriversLicenseCategory]
}

type DriversLicenseCategory {
  category: String
  issueDate: String
  expiresAt: String
}

type InsurancePackage {
  name: String!
  insuranceClass: String!
  coverage: [String]
  usages: String
}

# These types derived from https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/CognitoIdentityServiceProvider.html#adminGetUser-property
type User {
  Username: String!
  UserAttributes: [Value]
  UserCreateDate: String
  UserLastModifiedDate: String
  Enabled: Boolean
  UserStatus: UserStatus
  MFAOptions: [MFAOption]
  PreferredMfaSetting: String
  UserMFASettingList: String
}
type Value {
  Name: String!
  Value: String
}
type MFAOption {
  DeliveryMedium: String
  AttributeName: String
}
enum UserStatus {
  UNCONFIRMED
  CONFIRMED
  ARCHIVED
  COMPROMISED
  UNKNOWN
  RESET_REQUIRED
  FORCE_CHANGE_PASSWORD
}

enum ConnectionStatus {
  ACCEPTED
  REJECTED
}

# Used to model a Cognito user, not a 'real' DynamoDB type
# type UserCognito {
#   id: ID! # Custom attribute
#   name: String! # Full Name (includes middle name)
#   given_name: String! # First name
#   family_name: String! # Surname
#   middle_name: String! # Father's name!
#   preferred_username: String!
#   picture: String!
#   email: String!
#   email_verified: Boolean!
#   gender: String!
#   birthdate: String!
#   locale: String!
#   phone_number: String!
#   phone_number_verified: Boolean!
#   address: AWSJSON! # Specific json, check https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims
#   updated_at: AWSDateTime!
# }
